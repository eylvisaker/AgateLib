//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Glsl {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Shaders {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Shaders() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Glsl.Shaders", typeof(Shaders).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to uniform sampler2D DecalTex; //The texture
        ///uniform sampler2D BumpTex; //The bump-map 
        ///
        ///varying vec4 passcolor; //Receiving the vertex color from the vertex shader
        ///varying vec3 LightDir; //Receiving the transformed light direction 
        ///
        ///void main() 
        ///{
        ///	//Get the color of the bump-map
        ///	vec3 BumpNorm = vec3(texture2D(BumpTex, gl_TexCoord[0].xy));
        ///	
        ///	//Get the color of the texture
        ///	vec3 DecalCol = vec3(texture2D(DecalTex, gl_TexCoord[0].xy));
        ///	
        ///	//Expand the bump-map into a normalized signed vector
        ///	B [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BumpMap_fragment {
            get {
                return ResourceManager.GetString("BumpMap_fragment", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to varying vec4 passcolor; //The vertex color passed
        ///varying vec3 LightDir; //The transformed light direction, to pass to the fragment shader
        ///attribute vec3 tangent; //The inverse tangent to the geometry
        ///attribute vec3 binormal; //The inverse binormal to the geometry
        ///uniform vec3 lightdir; //The direction the light is shining
        ///
        ///void main() 
        ///{
        ///	//Put the color in a varying variable
        ///	passcolor = gl_Color;
        ///	
        ///	//Put the vertex in the position passed
        ///	gl_Position = ftransform(); 
        ///	
        ///	//Construct a 3x3 m [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BumpMap_vertex {
            get {
                return ResourceManager.GetString("BumpMap_vertex", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to varying vec4 diffuse,ambientGlobal, ambient;
        ///varying vec3 normal,lightDir,halfVector;
        ///varying float dist;
        ///uniform sampler2D tex;
        ///uniform sampler2D tex2;
        ///
        ///void main()
        ///{
        ///	vec3 n,halfV,viewV,ldir;
        ///	float NdotL,NdotHV;
        ///	vec4 color = ambientGlobal;
        ///	float att;
        ///	
        ///	/* a fragment shader can&apos;t write a varying variable, hence we need
        ///	a new variable to store the normalized interpolated normal */
        ///	n = normalize(normal);
        ///	
        ///	/* compute the dot product between normal and normalized lightdir */
        ///	NdotL =  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string PerPixelLighting_fragment {
            get {
                return ResourceManager.GetString("PerPixelLighting_fragment", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to varying vec4 diffuse,ambientGlobal,ambient;
        ///varying vec3 normal,lightDir,halfVector;
        ///varying float dist;
        ///
        ///void main()
        ///{	
        ///	vec4 ecPos;
        ///	vec3 aux;
        ///	
        ///	normal = normalize(gl_NormalMatrix * gl_Normal);
        ///	
        ///	/* these are the new lines of code to compute the light&apos;s direction */
        ///	ecPos = gl_ModelViewMatrix * gl_Vertex;
        ///	aux = vec3(gl_LightSource[0].position-ecPos);
        ///	lightDir = normalize(aux);
        ///	dist = length(aux);
        ///
        ///	halfVector = normalize(gl_LightSource[0].halfVector.xyz);
        ///	
        ///	/* Compute the diffuse [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string PerPixelLighting_vertex {
            get {
                return ResourceManager.GetString("PerPixelLighting_vertex", resourceCulture);
            }
        }
    }
}
